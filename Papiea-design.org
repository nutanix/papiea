#+Title: Papiea Design
#+SETUPFILE: https://fniessen.github.io/org-html-themes/src/theme-readtheorg.setup
#+Options: H:5
#+HTML_MATHJAX: align: left indent: 5em tagside: left font: Neo-Euler

#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+HTML_HEAD: <style>#content{max-width:70%;} </style>
#+HTML_HEAD: <style>div > ol.org-ol > li {margin-bottom:5px !important; /*color:red !important*/} </style>
#+HTML_HEAD: <style>.nav .timestamp {color: inherit;}</style>

#+OPTIONS: auto-id:t

#+EMAIL: [[mailto:shlomi.vaknin@nutanix.com][shlomi.vaknin@nutanix.com]]

#+OPTIONS: prop:("VERSION")

#+HTML: <div class="outline-2" id="meta">
| *Author*   | {{{author}}} ({{{email}}})    |
| *Date*     | {{{time(%Y-%m-%d %H:%M:%S)}}} |
| *Revision* | DRAFT                         |
#+HTML: </div>

Papiea is aimed to be a reference implementation of a [[*Formalities][formal general purpose intent engine]].

* Definitions
  :PROPERTIES:
  :CUSTOM_ID: h-Definitions-669
  :END:
  - _Spec_ - a map containing the desired state of a particular entity
  - _Status_ - a map containing the current statue of a particular entity. Always a superset of Spec
  - _Metadata_ - Information of the identity of the entity. Must contain at least =uuid=, =kind= and =specVersion=
  - _Spec version_ - an integer representing the version of the current spec. Updates to spec will
    use this field to ensure that the change will be atomic
  - _Entity_ - The tuple =[Metadata, Spec, Status]=
  - _Kind_ - The "type" of the entity
  - _Diff_ - A difference between the current Status and the most recent desired Spec
  - _Providers_ - Pluggable handlers that can transform an entity from its current state to its desired state
  - _Tasks_ - a mechanism for following the progress of resolving Diffs
* Basic Interfaces
  :PROPERTIES:
  :CUSTOM_ID: h-Basic-Interfaces-186
  :END:
  
  The main concept behind the intentful approach is the ability to know what is the desired state of
  our system and what is the actual current state. Once we have this knowledge, many different kinds
  of engines could be built that would attempt to resolve to tension formed when the intended state,
  termed the =Spec=, is different from the current state of the system, termed the =Status=.

  In Papiea, we use both =Spec= and =Status= to have a complete view of the state of a given entity
  identity, marked by the =Metadata=. The following interfaces capture these most basic concepts.
  
** Metadata
   :PROPERTIES:
   :ID:       papiea-Metadata-107
   :CUSTOM_ID: h-Metadata-350
   :END:
   
   Metadata has a structured portion which contains fields that defines the identity of a particular
   entity. The fields that identify the entity are:
   - =uuid= - a unique id representing the identity of this entity
   - =kind= - the "type" of this entity
   - =spec_version= - the most up-to-date revision of the spec associated with this entity

   Other fields are also important:
   - =created_at= - logs when this entity was created
   - =delete_at= - annouces if and when will this entity be deleted. If this field is set the entity
     will be deleted by a [[*Cleanup process][Cleanup process]].
    
   #+Name: metadata-struct
   #+BEGIN_SRC typescript
     export interface Metadata {
         // Identity fields
         uuid: uuid4;
         kind: string;
         spec_version: number;

         // Additional fields
         created_at: Date;
         delete_at: Date;
     }
   #+END_SRC
  
** Spec
   :PROPERTIES:
   :ID:       papiea-Spec-833
   :CUSTOM_ID: h-Spec-715
   :END:
   
   The =Spec=, which is the desired state, is simply a json object, or an unstructured map. It can
   and should get a structure when used specifically by any particular entity [[*Kind][Kind]]. However, at the
   engine level, a spec is an unstructured map that can be compared to the mirroring =Status= map to
   find any differences. The structure definintion may change by the provider which defines it, say
   by upgrading to a newer version (See TODO:).

   #+Name: spec-struct
   #+BEGIN_SRC typescript
   export type Spec = any;
   #+END_SRC

** Status
   :PROPERTIES:
   :ID:       papiea-Status-714
   :CUSTOM_ID: h-Status-990
   :END:
   
   The =Status=, which is a representation of the true current state of the entity, is also simply a
   json. Its content and structure is a superset of [[*Spec][Spec]], meaning that every field in =Spec= will
   also appear in =Status=, but may contain any extra fields as desired by the provider.

   I am just learning typescript, so still not sure how to express that =Status= is an extension of
   =Spec=, but it should be explicit.

   #+Name: status-struct
   #+BEGIN_SRC typescript
   export type Status = any;
   #+END_SRC

** Entity
   :PROPERTIES:
   :ID:       papiea-Entity-682
   :CUSTOM_ID: h-Entity-43
   :END:
   
   An Entity is simply the tuple =(Metadata, Spec, Status)=. It usually denotes a snapshot in time of a particular entity.

   #+Name: entity-struct
   #+BEGIN_SRC typescript
     export interface Entity {
       metadata: Metadata;
       spec: Spec;
       status: Status
     }
   #+END_SRC

   An Entity may be one of three types:
   1. =Spec-only entity= - an entity that has no real resource behind it. Meaning whatever the user desires is
      immediately fulfilled. This entity has no notion of =status=, and never contains a diff.
   2. =Status-only entity= - an entity that has a resource that is fully managed by something other than Papiea. We may
      observe its continuesly changing status, but since we have no notion of =spec=, there can be no diff.
   3. =Regular entity= - has both spec and status. May have status-only fields (read-only) or spec-only fields
      (write-only)

   Although these three types of entities make sense, in reality we may only distinguish between a =spec-only= entity
   and a =regular entity=. A =Status-only= entity could be achieved simply by marking every field as
   =status-only=. However, we could have =status-only= flag on an entity definition as a syntax sugar instead of
   manually marking each and every field as =status-only=.

   Here are some examples of an entity yaml:
   
   1. A regular entity that have one field as a =status-only= field
     #+BEGIN_SRC yaml
       File:
         type: object
         title: A File
         description: a file entity
         properties:
           name:
             type: string
           path:
             type: string
           md5-sum:
             type: string
             x-papiea-field: status-only
     #+END_SRC

     In here we will have the two following schemas:
       #+BEGIN_EXAMPLE
       Spec 'File':
         String name
         String path

       Status 'File':
         String name
         String path
         String md5-sum
       #+END_EXAMPLE

   2. A spec only entity:
      #+BEGIN_SRC yaml
        Geolocation:
          type: object
          title: Geographic Location
          description: A physical location of a data center
          x-papiea-entity: spec-only
          properties:
            name:
              type: string
            coordinates:
              type: object
              properties:
                lat:
                  type: number
                lon:
                  type: number
      #+END_SRC

      In this example we will not have a status schema generated at all, and we will also never find diffs:
      #+BEGIN_EXAMPLE
        Spec 'Geolocation':
          String name
          coordinates:
            Number lat
            Number lon
      #+END_EXAMPLE

      We may definetly come up with a better syntax than this verbose yaml, but its a good place to start. It also
      allows for an easier generaration of the resulting system-wide swagger yaml file for later consumption by
      users. Here is an example of such DSL:

      #+BEGIN_EXAMPLE
        Entity File (Files):
         "Some nice description"
         - String name
         - String type
         - String md5-sum (Status-only)

        Spec-only Entity Geolocation (geolocations):
         "another
          multiline description"
         - String name
         - coordinates:
           - Number lat
           - Number lon
      #+END_EXAMPLE

** Core types
   :PROPERTIES:
   :CUSTOM_ID: h-Coretypes-732
   :END:
   #+Name: core-types
   #+BEGIN_SRC typescript
     // Calback url is just a string
     export type Provider_Callback_URL = string;

     // Store a struct description parsed from Swagger Model YAML
     export type Data_Description = any;

     // Lets define a type for a version. For now it may be string, but could be more
     // elaborate later on
     export type Version = string;
   #+END_SRC
** Kind
   :PROPERTIES:
   :ID:       papiea-Kind-304
   :CUSTOM_ID: h-Kind-241
   :END:
   
   A Kind is the entity's metadata. It contains an entire description of what the entity is and what
   it may do. This information will be used to provideing full CRUD operation on the entity
   structure along with custom procedures and intentful handlers.

   #+Name: kind-struct
   #+BEGIN_SRC typescript
     export interface Kind {

         // The name of the kind, and its plural form for proper REST naming
         name: string;
         name_plural: string;

         //// Entity structure
         kind_structure: core.Data_Description;
         validator_fn: (entity:core.Entity)=>boolean;
         semantic_validator_fn?: core.Provider_Callback_URL; 

         //// Intentful behavior
         intentful_signatures: core.Map<core.SFS, core.Intentful_Signature>;

         // Every sfs lists the sfs's it has to execute before
         dependency_tree: core.Map<core.SFS, core.SFS[]>;

         // The compiled Differ
         differ: differ.Differ;

         //// Procedural behavior
         procedures: core.Map<string, Procedural_Signature>;
     }
   #+END_SRC
   
   A Kind metadata contains the following pieces:
   1. Identification and structure:
      1. a unique name along with its plural form, to generate idiomatic REST API. There may be a
         library function that create plural form, if so it should be used instead.

      2. The description of the data structre defined by this kind. The structure is defined using
         OpenAPI's model format (Swagger), which is parsed into a walkable tree.

      3. A Validator function is generated from this OpenAPI model specification. The purpose of the
         validator function is to ensure that the entity that was sent by the user is syntactically
         (structurally) correct.

      4. an optional semantic validator function is defined as a predicate exposed by the [[*Provider's SDK][Provider's
         SDK]]. It will be used to ensure that the content of the entity is correct.

   2. Intentful behavior
      1. A map from an intentful signature (see [[*SFS - Status Fields Signature][SFS - Status Fields Signature]]) to a structure
         representing the intentful behavior (see TODO:).

      2. Dependency tree between the different intentful behaviors.

      3. Using the two items above, a =Differ= is compiled. The Differ's task is to determine if
         there are any relevant differences between an entity's spec and status (relevant in this
         context means "a diff such that there exists at least one intentful behavior which can
         resolve it").

   3. Procedural behavior
      1. a map from the procedure name to a structure defining that procedure, its input argument
         and output result structures, execution strategy, etc. (see TODO:)
  
** Entity Reference
   :PROPERTIES:
   :ID:       papiea-Entity-Reference-223
   :CUSTOM_ID: h-Entity-Reference-396
   :END:
   
   Entities can point to other entities using a reference. A reference may onlu refers to the
   identity of an entity, and it is the intent engine that returns the entity's most recent spec and
   most current status.

   #+Name: entity-reference-struct
   #+BEGIN_SRC typescript
     export interface Entity_Reference  {
         uuid: uuid4;
         kind: string;

         // This field is optional and is only used help the user identify
         // what this reference is pointing to. 
         name?: string;
     }
   #+END_SRC

** Provider description
   :PROPERTIES:
   :ID:       papiea-Provider-description-839
   :CUSTOM_ID: h-Provider-description-189
   :END:
   
   Papiea is extensible by the use of =Providers=.  A Provider defines entities by providing their
   structure, their procedures and intentful behaviors. Along with declaratively define the entity's
   structure, it also enables intentful behaviors by defining how differences between spec and
   status may be resolved. The Provider is pluggable at runtime, and should maintain no internal
   state, which should allow for simpler methods of scaling.

   #+Name: provider-desc-struct
   #+BEGIN_SRC typescript
     export interface Provider {
         // A unique identifier where all kinds will be under this prefix
         prefix: string;
         version: core.Version;
         kinds: Kind[]
     }
   #+END_SRC

   A =Provider Description= contains:
   1. A unique identifier for that provider
   2. A version of that provider
   3. The list of Kinds supported by this provider

* Modules
  :PROPERTIES:
  :CUSTOM_ID: h-Modules-830
  :END:
  
** Databases
   :PROPERTIES:
   :CUSTOM_ID: h-Databases-897
   :END:
   
   #+BEGIN_note
   *Multitenancy*: All databases are aware of tenants. It may be implemented as a column or
   attribute of a table or document, or as a different database with a different connect uri.
   #+END_note
   
*** Status
    :PROPERTIES:
    :CUSTOM_ID: h-Status-781
    :END:
    
    Status database will be a mapping from a metadata (namely, =uuid= and =kind=) to a status json document. 

    It may be implemented using a fast in-memory database, since it may require frequent rapid
    access depending on an entity's kind requirement. It is not required that this database be
    persisted to disk. Its content MUST always be re-acquirable by the providers, simply by asking
    all the providers to list up-to-date status of all objects known to them.

    Each provider for a kind will supply its entity's structure in its YAML.
    
**** Interface
     :PROPERTIES:
     :ID:       papiea-Interface-10
     :CUSTOM_ID: h-Interface-548
     :END:
     
    #+Name: status-db-interface
    #+BEGIN_SRC typescript

      export interface Status_DB{

          // Update the status in the status db. As long as the input is
          // correct this always succeeds.
          update_status(entity_ref:core.Entity_Reference, status:core.Status):boolean;

          // Gets the status of a particular entity from the db. Returns
          // both current metadata and status of the entity.
          get_status(entity_ref:core.Entity_Reference):core.Status;

          // List all status that have their fields match the ones given in
          // fields_map. E.g. we could look for all specs for `vm` kind that
          // have a certain ip:
          // list_status({"metadata": {"kind": "vm"},
          //              "status":   {"ip":   "10.0.0.10"}})
          //
          // We could come up with command such as greater-than etc at some
          // later point, or we could use a similar dsl to mongodb search
          // dsl.
          list_status(fields_map: any): [core.Entity_Reference, core.Status][];
      }

    #+END_SRC

*** Spec
    :PROPERTIES:
    :CUSTOM_ID: h-Spec-770
    :END:
    
    Unlike status which can always be fetched from the providers, spec is a record of the user's
    intent and must be persistent. It must also be scalable and highly available. It must have a
    clear notion of atomicity (such as compare-and-set/swap) in order to atomically update spec
    values.

**** Interface
     :PROPERTIES:
     :ID:       papiea-Interface-500
     :CUSTOM_ID: h-Interface-229
     :END:
     
    #+Name: spec-db-interface
    #+BEGIN_SRC typescript
    
      export interface Spec_DB {

          // Tries to update the spec. Succeeds only if the spec_version
          // field in metadata is currently equals to the one on record. The
          // implementation needs to CAS the spec_version to the increment
          // of itself, and return the new metadata with the new
          // spec_version and the new CASed in spec.
          update_spec(entity_metadata: core.Metadata, spec:core.Spec):[boolean, core.Metadata, core.Spec];

          // Get the spec of a particular entity from the db. Returns both
          // current metadata and the spec of that entity.
          get_spec(entity_ref: core.Entity_Reference):[core.Metadata, core.Spec];

          // List all specs that have their fields match the ones given in
          // fields_map. E.g. we could look for all specs for `vm` kind that
          // have a certain ip:
          // list_specs({"metadata": {"kind": "vm"},
          //             "spec":     {"ip":   "10.0.0.10"}})
          //
          // We could come up with command such as greater-than etc at some
          // later point, or we could use a similar dsl to mongodb search
          // dsl.
          list_specs(fields_map: any): [core.Metadata, core.Spec][];
      }

    #+END_SRC

*** Providers
    :PROPERTIES:
    :CUSTOM_ID: h-Providers-484
    :END:
    
    Providers database stores all the configurations a provider has registered (encoded in [[*Provider description][Provider
    description]] section). It is used by the engine to record which providers are registered. The
    engine uses this indirectly to initialize all user-facing APIs. This seperation makes it easy to
    scale the engine to many instances.

**** Interface
     :PROPERTIES:
     :ID:       papiea-Interface-613
     :CUSTOM_ID: h-Interface-104
     :END:
     
    #+Name: provider-db-interface
    #+BEGIN_SRC typescript

      export interface Provider_DB {

          // Register a new provider with the intent engine
          register_provider(provider: papiea.Provider):void;

          //Upgrade a provider - This should be in the admin?
          //upgrade_provider(from_provider: uuid4, to: providerDescription): Task;
          
          // get a provider
          get_provider(provider_prefix: string, version?: core.Version): papiea.Provider[]

          // List all registered providers
          list_providers(): papiea.Provider[]

          // Removes and de-registers a provider from the intent engine
          delete_provider(provider_uuid: core.uuid4): boolean;
      }

    #+END_SRC

** Dependent services
   :PROPERTIES:
   :CUSTOM_ID: h-Dependent-services-836
   :END:
   
*** Tasks
    :PROPERTIES:
    :CUSTOM_ID: h-Tasks-498
    :END:
    
    Papiea defines a task to be a mechanism that tracks the progress of change towards a
    *particular* spec version. It does not matter how the change took place: through a provider,
    manually or by an error. A task will listen on the relevant status changes and mark off the
    different fields as they get resolved. To get a clearer understanding of the logic underlying
    this please see [[*Intentful Tasks][Intentful Tasks]] section below.

    #+BEGIN_note
    Unlike the traditional definition of a task as a handle to a running process, Papiea does not
    start a particular thread or process to that works on a =Diff=. Instead the task simply listens
    the relevant changes in the entity and tracks its progress. 
    #+END_note
    
**** Interface
     :PROPERTIES:
     :ID:       papiea-Interface-556
     :CUSTOM_ID: h-Interface-766
     :END:
     
     #+Name: task-manager-interface
     #+BEGIN_SRC typescript
       export interface Task {
           wait():any;
           register_delta(diffs: differ.Diff[]):boolean;
       } 

       export interface Task_Creator {
           new_task (): Task;
           new_intentful_task (papiea: papiea.Papiea, entity: core.Entity_Reference, kind: papiea.Kind, spec: core.Spec): Task;
       }

       export interface Task_Manager {
       // Not yet defined..
       }

     #+END_SRC
    
     A Task allows you to wait for it to finish.

** Papiea Engine
   :PROPERTIES:
   :CUSTOM_ID: h-Papiea-Engine-337
   :END:
   
*** Initialize
    :PROPERTIES:
    :CUSTOM_ID: h-Initialize-613
    :END:
    
    When Papiea loads up, it needs to initialize its database connections, load the providers,
    generate entity validators and expose CRUD and [[*Procedures][Procedural]] APIs.
   
**** Interface
     :PROPERTIES:
     :ID:       papiea-Interface-228
     :CUSTOM_ID: h-Interface-680
     :END:
     
    #+Name: papiea-interface
    #+BEGIN_SRC typescript
      export interface Papiea {

          // api is the mechanism which adds REST endpoints to Papiea.
          api: any; // For now, this will be the type of the API router
          prefix: string;

          statusDb: status.Status_DB;
          specsDb: spec.Spec_DB;
          providersDb: provider.Provider_DB;
      } 
    #+END_SRC

**** Pseudocode
     :PROPERTIES:
     :CUSTOM_ID: h-Pseudocode-305
     :END:
     
     
     #+Name: initialize-papiea-pc
     #+BEGIN_SRC typescript
       // Initialize papiea engine.
       function initialize_papiea(config): Papiea {
           papiea = new Papiea();

           // Load databases, initialize db connections.
           papiea.statusDb = Status_DB.connect(config.status_db);
           papiea.specDb = Spec_DB.connect(config.spec_db);
           papiea.providersDb = Provider_DB.connect(config.provider_db);

           // Sets up the rest api engine.
           papiea.api = new rest.api()

           // Start admin facing apis.
           papiea.create_admin_facing_API();

           // Start providers facing apis.
           papiea.create_providers_facing_API();

           // Start user facing apis.
           papiea.create_user_facing_API();

           return papiea;
       }
     #+END_SRC
*** Exporting APIs
    :PROPERTIES:
    :CUSTOM_ID: h-Exporting-APIs-141
    :END:
    
    Papiea provides three tiers of APIs: Admin, Provider and User facing.

    #+Name: exporting-apis
    #+BEGIN_SRC typescript
      export interface papiea_APIs {
          create_admin_facing_API(papiea:Papiea):void
          create_provider_facing_API(papiea:Papiea):void
          create_user_facing_API(papiea:Papiea):void
      }
    #+END_SRC
    
    Next sections go into greater details into each of the apis.
**** Admin facing APIs
     :PROPERTIES:
     :CUSTOM_ID: h-Admin-facing-APIs-612
     :END:
     
     The admin apis exposed by Papiea are used to manage providers: registrating, upgrading, deleting etc.
***** Pseudocode
      :PROPERTIES:
      :CUSTOM_ID: h-Pseudocode-769
      :END:
      
      #+Name: admin-api-pc
      #+BEGIN_SRC typescript
        function create_admin_facing_API(papiea:Papiea) {
    
            // An example for registring a new provider from a provider description
            papiea.api.POST(papiea.api.prefix+ "/providers", function(req, res) {
                registerOrUpgradeProvider(req.providerDescription);
            });

            // ...
        }
      #+END_SRC
     
**** Provider facing APIs
     :PROPERTIES:
     :CUSTOM_ID: h-Provider-facing-APIs-636
     :END:
     
     Provider has two sets of APIs:
***** Provider's SDK    
      :PROPERTIES:
      :ID:       papiea-Providers-SDK-685
      :CUSTOM_ID: h-Providers-SDK-518
      :END:
      
      This is actually an SDK rather than an API. The distinction is that this is used by the
      providers developers to define and expose behaviors and APIs to the end user.

      This SDK will be availagble in a few languages: Javascript and golang are planned first, but
      more should come.

      The core is the =Provider= abstraction:
      #+Name: provider_sdk_ts_provider_interface
      #+BEGIN_SRC typescript
        // Api for the provider-sdk
        enum Provider_Power {On, Off, Suspended};

        interface Provider {
            new_kind(entity_yaml:core.Data_Description):Kind;
            version(version: core.Version):void;
            power(state: Provider_Power): Provider_Power;
        }
      #+END_SRC

      This allows us to register a new kind (see below), establish a version and change the "Power
      state" of this provider instance. 

      A Kind is added when the user supplies a valid description for the entity handled by this
      kind. Once the kind's entity description is validated, an object of type =Kind= is returned on
      which we can do the following things:
      
      #+Name: provider_sdk_ts_kind_interface
      #+BEGIN_SRC typescript
        enum Procedural_Execution_Strategy {Halt_Intentful};

        interface Kind {

            // Adds an intentful handler. Dispatched based on the signautre passed
            on(signature: string, name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):Intentful_Handler;

            // Convenient functions for constructing/destructing an entity. Could be implemented in terms of "on above"
            on_new(name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):void;
            on_del(name: string, rbac: any, handler: (ctx:IntentfulCtx, entity:any)=>void):void;

            // Adds a procedural behaviour to the entity
            procedure(name: string, rbac: any,
                      strategy: Procedural_Execution_Strategy,
                      input_desc: string,
                      output_desc: string,
                      handler: (ctx:ProceduralCtx, input:any)=>any):void;


            // Visualize all the intentful handlers and their priority
            visualize_intentful_handlers(filename:string):boolean;
        }
      #+END_SRC
      
      We can add an intentful behavior to any set of changes to the entity's fields, either status
      (through a real change to the underlying resource, or spec (through a newly submitted user's
      intent), by declaring a handler using the =on= function.

      We could also register a procedure on that entity. The procedure should not change status in
      ways that may cause a new differences. If that happens, the intent engine will try to
      "resolve" the diff incured by the procedure. A procedure may state what should happen during
      its execution. One such strategy is that no intentful behavior should be handled. If that is
      the case, when the procedure finishes execution, the =Differ= will run again on the entity to
      see if any new diffs are needed to be resolved.

      When we have multiple intentful handlers, it may be desirable to be able to define a
      dependency tree between the different intentful handlers. Which should execute before which:
      
      #+Name: provider_sdk_ts_intentful_handler_interface
      #+BEGIN_SRC typescript
        interface Intentful_Handler {
            // Establishes a dependency tree between the various handlers
            before(...handlers: Intentful_Handler[]):void;
        }
      #+END_SRC

      In this snippet, =h1.before(h2, h3)= would mean that if the =Differ= discovered that both
      =h1=, =h2= and =h3= are possibilities of execution, the handler =h1= should execute first,
      then =h2= and =h3= have no specific ordering. In cases of no order, the handler with the most
      specific signature (i.e. longest) should run first, if both are equal one would be selected at
      random.

      During the execution of an intentful handler, the following functionality could be used:
      #+Name: provider_sdk_ts_intentful_ctx_interface
      #+BEGIN_SRC typescript
        interface IntentfulCtx {
            update_status(metadata: core.Metadata, status: core.Status):boolean;
            update_progress(message:string, done_percent:number):boolean;
        }

        // For the time being these are equal. Later they may differ
        type ProceduralCtx=IntentfulCtx;
      #+END_SRC

      During the execution of a handler we may want to set up the status of the entity we are
      working on, or perhaps update the task with our progress (if we have one). 

      I would say that best practice is to have a single =get_status(entity_metadata)= function that
      constructs a full status map out of the real resource, and only call =update_status(metadata,
      get_status(metadata))=, as this will ensure that even in case of a crash the status we saved
      is the exact one that would any way be generated by looking at the real resource.

***** Provider to Papiea APIs
      :PROPERTIES:
      :CUSTOM_ID: h-Provider-to-Papiea-APIs-927
      :END:
      
     Provider facing APIs define the interactions between a provider and the
     intent-engine.  They let the provider register [[*SFS - Status Fields Signature][Status Fields Signature]]
     handlers for intentful apis, and handlers for procedural apis which will be exposed to
     the user.

     Three apis are exposed:
     - =POST "/status"= - sends a voluntary status update regarding an entity. Recieves a context
       which identifies the context in which this was called, the metadata of entity and its new
       status. This functionality is only exposed to the providers, since they are the only view
       Papiea has of the real world. 
     - =POST "/progress= - sends a voluntary progress update for the task, should one exist. 

     #+Name: provider-api-pc
     #+BEGIN_SRC typescript
       function create_provider_facing_API(papiea: Papiea) {
           // Registering Provider Facing APIs.
           api = papieaApis.api
           papieaPrefix = papieaApis.prefix

           // Status update is only exposed to providers. Users can't update status.
           api.POST(papiea+"/status", function(req, res) {
               res.status(statusDb.updateStatus(req.uuid, req.status) ? 200 : 400)
               return res;
           })

           // 
           api.POST(papiea+"/progress", function(req, res) {
               //...
               return res;
           })
       }
     #+END_SRC
**** User facing APIs
     :PROPERTIES:
     :CUSTOM_ID: h-User-facing-APIs-455
     :END:
     
     The user facing APIs will be generated from all the registered kinds of all registered
     providers. The following pseudo-code will be demosstrating how the CRUD may be implemented.

     #+Name: user-api-pc
     #+BEGIN_SRC typescript
       function create_user_facing_API(papiea: Papiea) {
           papiea.providers.listProviders.forEach((provider_desc)=>{
               provider_desc.kinds.forEach((kind)=>{

                   // define CRUD for entity:
                   // Create: 
                   papiea.api.POST(papiea.prefix + "/" + kind.name_plural, handler_spec_change(kind, papiea));

                   // Update: The core of our intentfullness
                   papiea.api.PUT(papiea.prefix + "/" + kind.name_plural + "/{uuid}", handler_spec_change(kind, papiea));

                   // Read
                   papiea.api.GET(papiea.prefix + "/" + kind.name_plural + "/{uuid}", (req, res)=>{

                       // metadata is stored in spec as well
                       let spec   = papiea.spec_db.get_spec({kind: kind.name, uuid: kind.uuid});
                       let status = papiea.status_db.get_status({kind: kind.name, uuid: kind.uuid});

                       res.status(200).send(entity(spec, status));
                       return;
                   });
               });
           });
       };
     #+END_SRC
     
     =Create= and =Update= are essentially the same, and the functionality that handles them is
     captured in [[*Change Spec Handler Pseudocode][=handle_spec_change=]].

*** Handling Potential Diffs    
    :PROPERTIES:
    :CUSTOM_ID: h-Handling-Potential-Diffs-911
    :END:
    
    The engine will check for potential diffs on entities as a response to a few events:
    1. A spec change took place
    2. A status change took place
    3. A predefined timeout happened
     
*** Change Spec
    :PROPERTIES:
    :CUSTOM_ID: h-Change-Spec-966
    :END:
    
    A spec can only change through the [[*User facing APIs][User facing APIs]]. It returns an [[*Intentful Tasks][Intentful Tasks]] which is then
    used to track this change. After the task is returned the system verifies that the change is
    correct, both syntactically and optionally semantically (See [[*Kind][Kind]]). If this passes, it then
    attempts to atomically apply this spec change. If it succeeds, the [[*Differ][Differ]] is invoked on the
    entity and the resulting =Diffs= are [[*Intentful Execution][Intentfuly Executed]]. However, if the engine fails to
    atomically swap in the new spec change, the returned =Task= will contain a failure. It is up to
    the user to get the new entity state, reaply the relevant changes and re-submit a new spec
    change.

**** Change Spec Handler Pseudocode
     :PROPERTIES:
     :CUSTOM_ID: h-Change-Spec-Handler-Pseudocode-359
     :END:
     
     #+BEGIN_SRC typescript
       function handle_spec_change(kind: Kind, papiea: Papiea) {
           return (req, res) => {
               if (!kind.validator_fn(req.spec)) {
                   res.status(400).send("Does not conform syntactically");
                   return;
               }

               if (kind.semantic_validator_fn && rest.post(kind.semantic_validator_fn, req.spec)!=200) {
                   res.status(400).send("Does not conform semantically");
                   return;
               }

               // create and return the task
               let task = create_task(...);
               return task; // magically return here.

               // The followin code should run after the return, so
               // maybe async, maybe some event loop etc.
               if (!papiea.spec_db.update_spec(req.metadata, req.spec)) {
                   task.fail("could not cas task")
               }

               // Get the newest status
               let status = papiea.status_db.get_status({kind: kind.name, uuid: req.entity.metadata.uuid});

               // Get the next diff. If the diff is a brand new item, the
               // next_func is an "on_new" func, similarly, if the spec is one
               // that removes the item the next func is an "on_del" func.
               let next_func : Diff = provider_desc.differ.next_diff(req.metadata, req.spec, status);

               // invoke it
               next_func.invoke();
           }
       }
     #+END_SRC

*** Update Status
    :PROPERTIES:
    :CUSTOM_ID: h-Update-Status-188
    :END:
    
    A change of status may only arrive from a provider through the [[*Provider's SDK][Provider's SDK]]'s =update_status=
    function. A change of status may cause differences with regards to a the current spec, and so it
    may also be a cause for executing intentful actions. Although it does not return an explicit
    =Task= an implicit one may be created (see [[*Intentful Tasks][Intentful Tasks]]). 

*** SFS - Status Fields Signature
    :PROPERTIES:
    :CUSTOM_ID: h-SFS---Status-Fields-Signature-400
    :END:
    
    The Status Fields Signature is a formal dsl that describes which fields in status have to change
    in order to resolve some difference. It is at the core of our Intentful Dispatch mechanism.

    Ths signature is essentially a string consisting of field names concatenated with a ".". All of
    the fields but the last one constitutes the =Path= that must be taken, and the last fields of
    the string describes the field which should differ. 

    A special case in this definition is when a value for a field is a vector. In this case, instead
    of a field we have an "Item identifier", which is also a list of fields concatenated with a ".",
    that describes the identity or the item we are looking for.

    Lets see some examples for a kind =hosts=:

    1. =name= - Matches when an existing host is asking to rename itself. See the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

         new spec change: {metadata {uuid "1234"
                                     kind "host"
                                     specVersion 4}
                           spec     {name "new name"                    << DIFF
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       In this example, after successfully setting the new spec, the entity would look like this:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 4}               << Updated
                                status   {name "a"
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}
                                spec     {name "new name"               << DIFF
                                          network  [{mac "1.1.1.1.1"
                                                     cidr "10.0.0.0"
                                                     prefix_length 24}]}}

       #+END_EXAMPLE

       We can see that the difference for the a particular host entity is only in the =name=
       field. Thus, we want to find a function that knows how to transform the =name= status
       field. The engine will invoke the function that can resolve this diff.

    2. =networks.+{mac}= a signature that matches when a new network is added into a vector found
       for key "networks" on an existing entity, where the new network is identified by a field
       called "mac". Lets see this in the example, considering the =current host entity= as before:
       #+BEGIN_EXAMPLE
         new spec change: {metadata {uuid "1234"
                                     kind "host"
                                     specVersion 4}
                           spec     {name "a"
                                     network  [{mac "1.1.1.1.1"
                                                cidr "10.0.0.0"
                                                prefix_length 24}
                                               {mac "2.2.2.2.2"     << DIFF
                                                cidr "10.1.0.0"
                                                prefix_length 24}]}}
       #+END_EXAMPLE

       And we can see that once this new spec change will be atomically swapped in, there will be a
       diff only in the =network= key, and a new item (identifiable by =mac=) will be added. We need
       to invoke a function that knows how to add new networks to existing hosts.

    3. =networks.{mac}.cidr= Similar to the previous example, however, in here we are listening on a
       change of the =cidr= field inside an _already existing network_ identifiable by =mac=. Now a
       function that changes cidr values for existing networks in existing hosts whould be invoked.
       
    4. =field_a, field_b= this is an example of a compound signature, which is matched when a single
       spec change has caused a difference in both =field_a= and =field_b= of a particular host.
       
    5. =field_a, inner.{id}.field_b= this is another example of a more complex signature, where a
       single spec change causes a difference in both =field_a= and =field_b= which is an existing
       compound object that lies inside a vector =inner= which is identified by =id=. Lets consider
       the following example:
       #+BEGIN_EXAMPLE
         current host entity : {metadata {uuid "1234"
                                          kind "host"
                                          specVersion 3}
                                status   {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}
                                spec     {field_a "value 1"
                                          inner   [{id 1
                                                    field_b "value 2"}]}}

         new spec change: {metadata {uuid "1234"
                                          kind "host"
                                          spec_version 4}
                            spec     {field_a "another val 1"               << DIFF
                                      inner   [{id 1
                                                field_b "another val 2"}]}} << DIFF

       #+END_EXAMPLE

       In this example, the SFS would match the spec change if it gets atomically swapped in
       properly.

**** Formal syntax of SFS
     :PROPERTIES:
     :CUSTOM_ID: h-Formal-syntax-of-SFS-18
     :END:
     
     The following is a formal syntax describing SFS:

     #+BEGIN_EXAMPLE
       S                = simple-complex     

       (* optimize simple case *)
       <simple-complex> = complex | simple 
       <non-simple>     = vector  | group    

       (* this trick avoids ambiguity *)
       complex          = (simple <'.'>)? c (<'.'> simple)? 

       (* Allows for arbitraty simple/non-simple combination without introducing ambiguity *)
       <c>              = non-simple (<'.'> non-simple)* | (non-simple <'.'>)+ simple (<'.'> c) 

       (* regular flow *)
       group            = <'['> simple-complex (<','> (<' '>)* simple-complex)*  <']'>
       simple           = path 
       <path>           = field (<'.'> field)*
       vector           = (add | del | change) <'{'> path <'}'>
       add              = <'+'>
       del              = <'-'>
       change           = epsilon
       <field>          = #'[a-zA-Z_0-9]+'
    #+END_EXAMPLE
    
    This includes a few tricks to make sure the grammar is unambiguous. I think there may be a better way using PEG's
    lookahead. Essentially the problem comes from =simple= not being evaluated greedily.

**** Interfaces    
     :PROPERTIES:
     :CUSTOM_ID: h-Interfaces-559
     :END:
     
     #+Name: SFS-interfaces
     #+BEGIN_SRC typescript
       // Intentful signature
       export type SFS = string;

       export interface Intentful_Signature {
           signature: SFS;
           compiled_signature: any
           function_callback: Provider_Callback_URL;
       }
     #+END_SRC
     
     =SFS= is simply a string

*** Intentful core
    :PROPERTIES:
    :CUSTOM_ID: h-Intentful-core-629
    :END:
    
    At the core of Papiea lies the intentful behavior mechanism. To establish this mechanism we need the following:
    1. A representation of the user desire ([[*Spec][Spec]])
    2. A representation of the system's state ([[*Status][Status]])
    3. A way to find the differences between the desired and current state ([[*Differ][Differ]])
    4. A way to act upon these differences in a deterministic, fault-tolerant way ([[*Intentful Execution][Intentful Execution]])
    5. A way to track the changes to completion ([[*Intentful Tasks][Intentful Tasks]])

    Once these items are there, the intentful mechanism is rather trivial. Lets see the following pseudo-code:
    
    #+BEGIN_SRC typescript
      // This is just conceptual to show how we are notified that a the
      // engine needs to look for a diff
      if (entity.status_changed() || entity.spec_changed() || entity.kind.timeout_reached()) {

          // Based on the intentful handlers registered by the provider
          // (namely, their SFS signatures), the constructed `differ` will
          // return the next diff to handle.
          diff = entity.kind.differ.next_diff(entity.status, entity.spec);

          // Look in Tasks, to see if there is a task that is not yet
          // resolved and is listening for this particular change.
          task = Tasks.create_or_get(entity, diff);

          // When the trigger for this change is a `spec change` the
          // returned task will usually be the task created by the spec
          // change request itself. When a status change or a timeout
          // trigger this event, a task may not be present and so a new,
          // implicit one, should be created.

          // The task then sees if there is a currently working intentful
          // handler on this entity. If there is one currently working
          // (including making sure it is actually active), we stop
          // processing for this round
          if (task.is_intentful_handler_still_working() || task.is_running_a_procedure()) {
              return;
          }

          // If nothing intentful is working and we are also not running
          // anything procedural, lets invoke the intentful handler to
          // settle the diff.
          ret = diff.invoke();

          // The value returned in `ret` is not the result of applying the
          // intentful handler to the entity. We are not waiting for the
          // intentful method to complete. The return value is merely a
          // signal that the handler has started working, and a uuid
          // representing this currently executing handler.

          if (ret.code() == 200) {
              // This should actually be done inside the provider_sdk to
              // address failures:
              task.set_working_intentful_handler(ret.handler_uuid_url);
          }
      }
    #+END_SRC
**** Differ
     :PROPERTIES:
     :ID:       papiea-Differ-69
     :CUSTOM_ID: h-Differ-118
     :END:
     
     The differ is at the core of identifying the next intentful command to be invoked. It is required for a few reasons:

     1. A generic differ is too broad to fit an arbitrary data structure:
        - There are cases where it is impossible to differentiate between an internal object being
          changed and it being created or deleted. See the following example:

          Consider the following entity =e=. Lets see two versions of it, =e_1= and =e_2=:
          #+BEGIN_EXAMPLE
          e1 = {x: [{a:1, b:2}]
          e1 = {x: [{a:1, b:1}]
          #+END_EXAMPLE

          In this example we have a two valid interpertations of what happened to the inner object inside =x='s list:
          1. The object identity is defined by the field =a=. In this case, the object ={a:1, b:2}=
             simply changed its =b= component's value to =1=.

          2. The object identity is defined by the field =b=. In this case, the object ={a:1, b:2}=
             was removed, and a new object ={a:1, b:1}= was created

          This is just a simple case, but we can make it as complicated as we would like.

     2. If the system does not have any method of resolving a diff, then we should not look for that
        diff. Every field in spec needs to be able to handle a change of value, but that may not be
        the case in reality. It could be a bug, a partial implementation, a field in spec for future
        use etc. The best thing we could do with an unhandlable diff is print it.

        Having the Differ look at all possible diff handlers a provider exports, we could have
        automatic validation of which cases are handled, which cases are not handled and which cases
        may have more than a single possible handler thus may cause inconsistencies in a diff
        resolution.

     3. A generic differ may be reflective in nature and may suffer from degraded performance. A
        compiled diff could use the knowledge of what could be handled and the priority to have
        minimum number of branches to determine what handler will need to be invoked.

    Due to the items described above, it is desirable to be able to compile the differ from the
    signatures supplied by the provider, along with the dependency tree.
    
    The following interface defines the compiler function as well as the =Differ= interface. Given a
    kind, namely the intentful handlers signatures and the dependency tree, a =Differ= is built.
    #+Name: Differ-interface 
    #+BEGIN_SRC typescript
      export interface Kind_Compiler {
          // The sfss compiler function. 
          compile_kind_explicit(sfss: core.SFS[], dep_tree: core.Map<core.SFS, core.SFS[]>): Differ;

          // More concisely this could simply be:
          compile_kind(kind: papiea.Kind): Differ;
      }

      // The differ is used to locate a diff in an entity between the
      // current status and the desired state. 
      export interface Differ {

          // Get the next diff from an entity based on the 
          next_diff(entity:core.Entity_Reference, spec: core.Spec, status: core.Status):Diff;

          // We could also get the entire list of diffs, ordered by the
          // original dependency tree
          all_diffs(entity:core.Entity_Reference, spec: core.Spec, status: core.Status):Diff[];
      }
    #+END_SRC

**** Intentful Execution
     :PROPERTIES:
     :ID:       papiea-Intentful-Execution-841
     :CUSTOM_ID: h-Intentful-Execution-821
     :END:
     
     Once a =Diff= was constructed by the =Differ=, it can then execute the handler function on the
     proper provider. 

     #+Name: Diff-interface
     #+BEGIN_SRC typescript
      // The Diff structure captures a discovered diff in an entity as well
      // as the intentful action that may resolve such diff
      export interface Diff {
          // The uri exposed by the provider which may handle this diff
          intentful_fn_uri: core.Provider_Callback_URL

          // If this intent handler has a name, we could use it
          name?: string;

          // The fields identified by this differ, their path and value.
          diff_fields: core.Map<core.SFS, any>;

          // Actually invokes the intentful function
          invoke(): any;
      }
    #+END_SRC

    The =Diff= interface captures the fields that were matched by the sfs signatures (their path and
    value), and the actual intentful behavior function url which is then used by the invoke
    function.

    This =invoke= function will result in the execution of the function registered using
    =provider_sdk='s =on= command. Invoke is essentially an RPC command (for now over HTTP but my be
    implemented over other protocols) which only notifies the provider that it should start
    executing that handler.

*** Execution ID
    :PROPERTIES:
    :CUSTOM_ID: h-Execution-ID-534
    :END:
    
    In order for Papiea to keep track of the state of these decoupled execution paths, a simple
    technique is employed. In the =provider_sdk=, when an intentful command has been invoked, the
    system generates a unique uuid url which is then stored in perishable memory (meaning RAM,
    without being persisted) and registerd in the task. The uuid url is directing to a specific
    instance of the provider, meaning does not go through a load balancer.

    This allows the Papiea engine to handle failures in providers. At any time, such as during
    recovery or timeouts, Papiea could look at the task to see if any handler is still claimed to be
    working. It then takes the handler's uuid url, and tries to invoke it. If it succeeds, that
    means that the provider which is working on it still has that function running. If it failed it
    means that the provider does not know about this handler, and thus it can be safely removed. 

    Possible reasons why the provider will not recognize a uuid url:
    1. The provider has crashed and recovered. Since the provider is stateless and this uuid is not
       saved anywhere other than memory, it will not be familiar with that handler's uuid. This
       would mean that the engine needs to re-ask for this operation, or other operations if this
       operation partially succeeded and updated the status fields accordingly.

    2. The intent engine has crashed. The provider may have finished executing just fine and wanted
       to remove the uuid from the task. If the API it uses goes through Papiea and not directly, it
       may fail to update the task. Once Papiea has recovered, the task will still seem to be active
       and working on that handler, however, this mechanism would allow us to clear the task and
       issue the next handler to work on to the providers.

    3. Any failure in communication that causes the task not to get updated.

    This is not a WAL, it simply a mechanism that allows Papiea and a provider to know if something
    is still running or not, without having to to rely on waiting for anything to complete. Thus,
    this is a method for decoupling a caller from having to continuously and uninterruptedly
    listening to the callee.

*** Procedures Signatures
    :PROPERTIES:
    :CUSTOM_ID: h-Procedures-Signatures-983
    :END:
    
    Procedures are functions that providers can expose directly to an entity. These functions are
    not intentful by design, and usually cannot be expressed in terms of a spec change.

    For example, consider asking a host to reboot. The =Power= status of a host can either be =On=
    or =Off=. However, a reboot is not a state of a machine, its a transition of the power state,
    and thus cannot be expressed in terms of a desired state. It is said to be a =Procedure= that is
    exposed on the host kind.

    Similarly to SFS, procedures are also registring based on a signature, lets see an example:
    
    - =hosts/{metadata.uuid}/reboot= - This signature refers to a =host= kind, will look a particular
      host up by matching the given uuid to the =metadata.uuid= field of the host, and expose a
      function called =reboot=. Seeing this signature will cause the engine to add a the following new api end point for the
      host kind:
      #+BEGIN_EXAMPLE
      POST "/hosts/{uuid}/reboot" 
      #+END_EXAMPLE
  
      Where ={uuid}= value will be matched against the host's =metadata.uuid=. Once a POST request for this
      route has been received by the user, the request will be forwarded to the callback url provided at registration time.
    
**** Interface
     :PROPERTIES:
     :CUSTOM_ID: h-Interface-598
     :END:
     
     #+Name: procedure-signature
     #+BEGIN_SRC typescript
       // We may want to support different execution strategies. For now we
       // can only halt intentful execution for the duration of the
       // procedural call
       export enum Procedural_Execution_Strategy {Halt_Intentful};

       export interface Procedural_Signature {
           // The name of the procedure to be exported by the engine.
           name: string;

           // The representation of the data to be passed to this procedure
           argument: core.Data_Description;

           // The automatically generated validator
           arg_validator_fn: (arg:any)=>boolean;

           // The representation of the data to be returned from this procedure
           result: core.Data_Description;

           // The automatically generated validator
           result_validator_fn: (res:any)=>boolean;

           // Does the engine pauses all intentful operation invocations for
           // the duration of the procedural call
           execution_strategy: Procedural_Execution_Strategy;

           // Action url into the provider
           procedure_callback: core.Provider_Callback_URL;
       }

     #+END_SRC
*** Understanding Deltas
    :PROPERTIES:
    :CUSTOM_ID: h-Understanding-Deltas-526
    :END:
    
**** Matching SFSs to Deltas
     :PROPERTIES:
     :CUSTOM_ID: h-Matching-SFSs-to-Deltas-991
     :END:
     
**** Determining Order
     :PROPERTIES:
     :CUSTOM_ID: h-Determining-Order-968
     :END:
     
*** Provider
    :PROPERTIES:
    :CUSTOM_ID: h-Provider-776
    :END:
    
    This section describes provider handling on Papiea's side. For the provider itself, please see [[*Provider Library][Provider Library]].
    
    As described in [[*Provider facing APIs][Provider facing APIs]] section, providers interact with the intetful engine by
    registring callbacks for two styles of actions:
    - Intentful actions - which are executed by analyzing their [[*SFS - Status Fields Signature][Status Fields Signature]]
    - Procedural actions - which are executed by a user interaction

    The following interface defines the registration mechanism for both kinds of actions:

    #+Name: provider-handler-interface
    #+BEGIN_SRC go
      type provider_callbacks interface {
          registerIntentfulCallback(sig sfsSignature, callbackUrl string) err
          registerProceduralCallback(sig procedureSignature, callbackUrl string) err
      }
    #+END_SRC

    The following pseudocode describes how these may be implemented:

    #+Name: provider-handler-pc
    #+BEGIN_SRC go
      func (api_ctx papieaApiContext) registerIntentfulCallback(sig sfsSignature, callbackUrl string) err {
          deltaAnalyzer.register(sig, callbackUrl)
      }

      func (api_ctx papiea_api_ctx) registerProceduralCallback(sig procedureSignature, callbackUrl string) err {
          procedures.register(sig, callbackUrl)
      }
    #+END_SRC
*** RBCA - test
    :PROPERTIES:
    :CUSTOM_ID: h-RBCA---test-952
    :END:
    
*** Scalability and Reliability
    :PROPERTIES:
    :CUSTOM_ID: h-Scalability-and-Reliability-320
    :END:
    
**** Leader election
     :PROPERTIES:
     :CUSTOM_ID: h-Leader-election-671
     :END:
     
**** Fault tolerance
     :PROPERTIES:
     :CUSTOM_ID: h-Fault-tolerance-361
     :END:
     
***** Dead Papiea Instance
      :PROPERTIES:
      :CUSTOM_ID: h-Dead-Papiea-Instance-544
      :END:
      
***** Dead Provider
      :PROPERTIES:
      :CUSTOM_ID: h-Dead-Provider-284
      :END:
      
*** Cleanup process
    :PROPERTIES:
    :CUSTOM_ID: h-Cleanup-process-55
    :END:
    
    - automatic deletion?
*** Auditing
    :PROPERTIES:
    :CUSTOM_ID: h-Auditing-900
    :END:
    
** Intentful Tasks                                          :Continue_Fixing:
   :PROPERTIES:
   :CUSTOM_ID: h-Intentful-Tasks-117
   :END:
   
   Tasks are intentful in our intent engine. This means that a task defines an intent to "get
   notified when a certain change request has completed". 

   A new task may be created in the context of providing a new spec change or a status change. Since
   a spec change is atomically swapped by the engine, a task for a particular spec change may fail
   simply for not being able to atomically perform the swap (such as CAS failures in certain
   models). Once a spec change has been properly and atomically swapped in, the task registers a
   status change listener using [[*SFS - Status Fields Signature][SFS - Status Fields Signature]]. It will listen on all the fields that
   the spec change has requested to change. On every field, the following actions can happen:
   1. The field will get updated to the value that the spec change was requesting
      - Once this happens, this field is marked as successfully being fulfilled, the context of the
        status change may be logged for later auditing and the SFS for this field is stopped
   2. The field will get updated to a value that is *other* than the spec change was requesting
      - If this happens, the task will look to see if the spec version of the entity has increased
        - If it has, this field will be marked as *outdated* and teh SFS for this field is
          stopped. A reference to the outdating spec change may be maintained for later auditing.
        - If it still has the same spec version as the task, the task will not get updated
   
   Using this scheme, the task is said to be complete if there are no more active SFS listeners. It
   may be completed in three ways:
   1. Completed Successfully - All fields were set to the spec value at some point after the spec
      change was issued
   2. Completed Partially - Some fields were set to the spec value, and some were not due to a newer
      spec version
   3. Failed - non of the fields was changed to the given spec values, and there is already a newer
      spec version
   
   As long as there are still active SFS listeners in the task, it will be *pending*. It can show
   progress in terms of how many fields are left of the total fields. The intent engine will have to
   query pending tasks periodically to see if work has to be restarted.
   
   - TODO: What if a before a spec version has made a change to modify
     a field's value, a new spec change arrived that reverted the
     field's value to its value before the first spec change? This
     will cause status to never be updated because there is no
     difference between spec and status, but there is a task still
     listening.. Need to think about this
   
   #+Name: task-pc
   #+BEGIN_SRC typescript
     function new_intentful_task(papiea: Papiea, entity: Entity_Reference, kind: Kind, spec: Spec): Task {
         // Get the status of the entity we are trying to change.
         status = papiea.status_db.get_status(entity);

         // Calculate the delta between the spec and the status. calc_delta
         // will take into consideration all registered SFS for the
         // entity's kind in order to know how to diff on vector
         // elements. See more details in calc_delta. Each delta found will
         // record the corresponding SFS that could is registered which
         // should be able to resolve the diff
         deltas = kind.differ.all_difs(entity, spec, status);

         // we are the task
         task = new Task();

         // Register all the relevant deltas we could listen on
         task.register_delta(delta);

         for (field in deltaho) {
             // TBD: define on, define context
             fieldListener = papiea.on(field.sfs, func(context, updatedEntity entityReference, status status){
                 newValue = status.get(field.path)
                 specValue = spec.get(field.path)

                 if (newValue == specValue) {
                     // Update the task that this field in the delta is a success
                     task.updateFieldStatus(field, "Success")

                     // Stopping this listener
                     task.removeFieldListener(this)
                 }
                 else if (entity.metadata.specVersion == updatedEntity.metadata.specVersion) {
                     // We got a different value, but still on the same spec version, dont do anything yet
                     // Add to audit
                     // Perhaps note this in some TTL
                 }
                 else {
                     // We got a different value AND the spec version has increased (it can only increase)

                     // update the task that this field is outdated by a particular spec version
                     task.updateFieldStatus(field, "Outdated by " + updatedEntity.metadata.specVersion)

                     // Stopping this listener
                     task.removeFieldListener(this)
                 }

                 task.verifyCompletness()
             })

             task.addFieldListener(fieldListener)
         }
     }

     func (papiea papiea) verifyCompletness() {
         if (task.noMoreFieldListeners()) {
             if (task.specDidNotRegister()) {
                 task.setStatus("Spec did not manage to be atomically committed. Try again.")
             }
             else if (task.hasFailedFields()) {
                 task.setStatus("Partially Completed")
             } else {
                 task.setStatus("Completed Successfully")
             }
         }
     }
   #+END_SRC
** Provider Library
   :PROPERTIES:
   :CUSTOM_ID: h-Provider-Library-729
   :END:
   
*** Define Entity Model
    :PROPERTIES:
    :CUSTOM_ID: h-Define-Entity-Model-393
    :END:
    
**** YAML
     :PROPERTIES:
     :CUSTOM_ID: h-YAML-342
     :END:
     
**** CRUD
     :PROPERTIES:
     :CUSTOM_ID: h-CRUD-68
     :END:
     
*** Initialize
    :PROPERTIES:
    :CUSTOM_ID: h-Initialize-384
    :END:
    
*** Callback Mechanism
    :PROPERTIES:
    :CUSTOM_ID: h-Callback-Mechanism-760
    :END:
    
*** Running Effect Validator
    :PROPERTIES:
    :CUSTOM_ID: h-Running-Effect-Validator-934
    :END:
    
*** Status Changes Handlers
    :PROPERTIES:
    :CUSTOM_ID: h-Status-Changes-Handlers-305
    :END:
    
**** Registring
     :PROPERTIES:
     :CUSTOM_ID: h-Registring-364
     :END:
     
**** Running using context
     :PROPERTIES:
     :CUSTOM_ID: h-Running-using-context-1
     :END:
     
*** Procedures
    :PROPERTIES:
    :CUSTOM_ID: h-Procedures-910
    :END:
    
**** Registring
     :PROPERTIES:
     :CUSTOM_ID: h-Registring-726
     :END:
     
**** Running using context
     :PROPERTIES:
     :CUSTOM_ID: h-Running-using-context-963
     :END:
     
*** Example Provider
    :PROPERTIES:
    :CUSTOM_ID: h-Example-Provider-853
    :END:
    
* Full files
  :PROPERTIES:
  :CUSTOM_ID: h-Full-files-475
  :END:
** Core definitions
   :PROPERTIES:
   :CUSTOM_ID: h-Core-definitions-249
   :END:
   
*** /src/core.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srccorets-990
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/core.ts :exports code :mkdirp yes :comments noweb

      // This should probably be imported from some library
      export type uuid4 = string;

      // This should be provided by the typescript, could not figure it out for now.
      // See https://stackoverflow.com/a/50826619
      export interface Map<K, V> {
          clear(): void;
          delete(key: K): boolean;
          forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void,thisArg?: any): void;
          get(key: K): V | undefined;
          has(key: K): boolean;
          set(key: K, value: V): this;
          readonly size: number;
      }

      //export type Map<K,V> = {[k:string]:V};

      <<core-types>>
    
      <<metadata-struct>>

      <<spec-struct>>

      <<status-struct>>

      <<entity-struct>>

      <<SFS-interfaces>>

      <<entity-reference-struct>>
    #+END_SRC

*** /src/papiea.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srcpapieats-146
    :END:
    #+BEGIN_SRC typescript :noweb yes :tangle src/papiea.ts :exports code :mkdirp yes :comments noweb
      import * as core from "./core"
      import * as differ from "./intentful_core/differ_interface"
      import * as spec from "./databases/spec_db_interface"
      import * as status from "./databases/status_db_interface"
      import * as provider from "./databases/provider_db_interface"

      <<kind-struct>>

      <<procedure-signature>>

      <<provider-desc-struct>>

      <<papiea-interface>>

    #+END_SRC
** Databases
   :PROPERTIES:
   :CUSTOM_ID: h-Databases-346
   :END:
   
*** /src/databases/spec_db_interface.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srcdatabasesspec_db_interfacets-571
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/databases/spec_db_interface.ts :exports code :mkdirp yes :comments noweb
    import * as core from "../core";
    import * as papiea from "../papiea";

    <<spec-db-interface>>
    #+END_SRC

*** /src/databases/status_db_interface.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srcdatabasesstatus_db_interfacets-127
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/databases/status_db_interface.ts :exports code :mkdirp yes :comments noweb
    import * as core from "../core";
    import * as papiea from "../papiea";

    <<status-db-interface>>
    #+END_SRC

*** /src/databases/provider_db_interface.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srcdatabasesproviders_db_interfacets-582
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/databases/provider_db_interface.ts :exports code :mkdirp yes :comments noweb
    import * as core from "../core";
    import * as papiea from "../papiea";

    <<provider-db-interface>>
    #+END_SRC

** Differ   
   :PROPERTIES:
   :CUSTOM_ID: h-Differ-646
   :END:
   
*** /src/intentful_core/differ_interface.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srcintentful_corediffer_interfacets-83
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/intentful_core/differ_interface.ts :exports code :mkdirp yes :comments noweb
    import * as core from "../core";
    import * as papiea from "../papiea";

    <<Differ-interface>>

    <<Diff-interface>>
    #+END_SRC
** Tasks
   :PROPERTIES:
   :CUSTOM_ID: h-Tasks-912
   :END:
   
*** /src/tasks/task_manager_interface.ts
    :PROPERTIES:
    :CUSTOM_ID: h-srctaskstask_manager_interfacets-833
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/tasks/task_manager_interface.ts :exports code :mkdirp yes :comments noweb
      import * as papiea from "../papiea";
      import * as core from "../core";
      import * as differ from "../intentful_core/differ_interface"

      <<task-manager-interface>>
    #+END_SRC

** Provider SDK
   :PROPERTIES:
   :CUSTOM_ID: h-Provider-SDK-909
   :END:
   
*** Typescript: /src/provider_sdk/typescript_sdk_interface
    :PROPERTIES:
    :CUSTOM_ID: h-Typescript:-srcprovider_sdktypescript_sdk_interface-851
    :END:
    
    #+BEGIN_SRC typescript :noweb yes :tangle src/provider_sdk/typescript_sdk_interface.ts :exports code :mkdirp yes :comments noweb
    import * as core from "../core";
    
    <<provider_sdk_ts_provider_interface>>

    <<provider_sdk_ts_kind_interface>>

    <<provider_sdk_ts_intentful_handler_interface>>

    <<provider_sdk_ts_intentful_ctx_interface>>
    #+END_SRC


* Formalities
  :PROPERTIES:
  :CUSTOM_ID: h-Formalities-320
  :END:
  
  Handling resources at a large enough scale can become quite a tedious job. There are many loosly
  connected moving parts that all strive to keep in sync. In reality this keeping in sync is an
  assumption we cannot have, so we handle errors. Errors are tricky to maintain since recovering
  from an error is defined by the context of the error. There are many techniques to approach error
  handling, but for the problem of manipulating resources, we belive that an "Intentful Programming"
  approach may be more suitable. 

  The word "Intentful" could mean many things. One way would be to treat it as "Fulfilling a
  desire". Why? because when you have a desire that needs fullfiling, every action that you make,
  you make with the intent of solving the dissonance between what it is you actually have and what
  it is you desire to have. 

  This defintion is useful because we can draw some formalities out of it: 
  1. Let $T=\{(p,v)|p \in properties, v \in values\}$ be a representation of a state in our
     world. For practical reasons, lets define it to be a set of properties and their values, which
     collectively define the state.
  3. Let $cs \in T$ be a represention of "what it is we *actually have*"
  4. Let $ds \in T$ be a represention of "what it is we *desire to have*"
  5. Let $have=cs \setminus ds$ be all the things that we *have* and dont want
  6. Let $want=ds \setminus cs$ be all the things that we do *want*
  7. Let $diff=\{(p, v_{old}, v_{new})|(p,v_{old})\in have, (p, v_{new})\in want\}$

  Now we know exactly which properties have to change, from what value and to what value, in order
  to fulfil our desire. The next step is to define functions that can transform states. Lets develop
  some intuition about how we approach fulfiling a desire:
  
  Lets say that we are thirsty. This sensation is captured in a property. Lets say we also have a
  cup, and that the cup property has the value "full". In that case, our resolving function would be
  to drink from the cup. If the cup is not "full", we will have a brand new desire, to fill the
  cup. We could do that with the "faucet" property, by setting its value to "open", which is yet
  another desire. So lets model that:
  1. $properties={hydration, cup, faucet}$
  2. $values=\{thirsty, quenched, full, empty, open, close\}$. Of course we could split this up so
     properties may have values from close sets, but lets not get too rigorous for now.

  Now lets define some functions:
  1. $drink:T \to T$
  2. $faucet_{open}: T \to T$
  3. $fillcup: T \to T$
  2. $faucet_{close}: T \to T$

  At the end of applying any of the above function on $cs$, we get a new, different $cs$. We can
  also get a new $cs$ spontaniously, say magically the water got spilled from the cup or the faucet
  broke. When $cs$ changes for whatever reason, we recalculate $diff$. Our goal is to have
  $|diff|=0$

  To make an action, we need to examine the different possibilities:
  1. If $\{(hydration, thirsty, quenched), (cup, _, full)\} \in diff$ then $drink$ 
  2. If $\{(hydration, thirsty, quenched), (cup, empty, full), (faucet, closed, open)\}\in diff$ then
     $faucet_{open}$
  3. If $\{(hydration, thirsty, quenched), (cup, empty, full), (faucet, open, open)\}\in diff$ then $fillcup$
  4. If $\{(faucet, open, closed)\}\in diff$ then $faucet_{close}$

  Lets generalize:
  1. Let $pred=\wp(diff)$, the power-set of $diff$
  2. Lets assign to each function $fn$ the set $dispatch_{fn} \in pred$, which is the set such that
     when it exists in $pred$ this function $fn$ is applied on $cs$

  This last assignment is essentially establising a function dispatch mechanism on top of the $diff$
  we managed to calculate from our representation of states in our world. The set assigned
  identifies the action that needs to happen when either a new desire enters the system, or the
  current status of the system changed without changing the desire. In our example, hydration
  property of the current state was changed to "thirsty" while the desired state of "quenched" is
  present. This system makes sure that we are never thirsty, given that we have a cup and a
  faucet. We effectively not only fulfilled a desire, but also make sure it always stays fulfilled.

  So the next step is what to do when there are a few desires simultaneously. How do we determine
  what to do first? We could simply keep all our $dispatch_{fn}$s in a list, ordered by our
  perceived priorities. For example, do we first drink or do we first close the faucet?

  Let $dlist=(dispatch_{fn_1}, ..., dispatch_{fn_k})$, at every time we recalculate $diff$, we
  iterate through this ordered list one item at a time, see if $dispatch_{fn_i} \subset diff$. If it is,
  ${fn_i}$ is applied, $cs$ and $diff$ are recalculated, and we run thrugh $dlist$ again from the top.

* Last notes
  :PROPERTIES:
  :CUSTOM_ID: h-Last-notes-822
  :END:
  
  - I followed [[http://ehneilsen.net/notebook/orgExamples/org-examples.html][this tutorial]] for generating the source files through this org-mode.
